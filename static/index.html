<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ParkVision - Smart Parking Management</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #0a0e27;
            color: #e0e0e0;
            overflow-x: hidden;
        }

        /* Header */
        .header {
            background: #0f1629;
            padding: 20px 40px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #1a2332;
        }

        .logo-section {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .logo {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, #00d4ff 0%, #00a8cc 100%);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 20px;
            color: white;
        }

        .logo-text h1 {
            font-size: 24px;
            font-weight: 600;
            color: white;
            margin: 0;
        }

        .logo-text p {
            font-size: 12px;
            color: #8b8b8b;
            margin: 0;
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: #1a2332;
            border-radius: 20px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            background: #00ff88;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .icon-btn {
            width: 40px;
            height: 40px;
            background: #1a2332;
            border: none;
            border-radius: 8px;
            color: #8b8b8b;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            position: relative;
        }

        .icon-btn:hover {
            background: #252d3f;
            color: white;
        }

        .notification-badge {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 8px;
            height: 8px;
            background: #ff4444;
            border-radius: 50%;
        }

        /* Main Container */
        .container {
            padding: 30px 40px;
            max-width: 1920px;
            margin: 0 auto;
        }

        /* Stats Grid */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: #131a2e;
            border: 1px solid #1a2332;
            border-radius: 12px;
            padding: 24px;
            position: relative;
            overflow: hidden;
        }

        .stat-card::before {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 80px;
            height: 80px;
            opacity: 0.1;
            background: currentColor;
            border-radius: 50%;
            transform: translate(20px, -20px);
        }

        .stat-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 16px;
        }

        .stat-title {
            font-size: 12px;
            color: #8b8b8b;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-icon {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
        }

        .stat-value {
            font-size: 36px;
            font-weight: 700;
            margin-bottom: 8px;
        }

        .stat-subtitle {
            font-size: 14px;
            color: #8b8b8b;
        }

        .stat-card.total .stat-value { color: #00d4ff; }
        .stat-card.total .stat-icon { background: rgba(0, 212, 255, 0.2); color: #00d4ff; }

        .stat-card.available .stat-value { color: #00ff88; }
        .stat-card.available .stat-icon { background: rgba(0, 255, 136, 0.2); color: #00ff88; }

        .stat-card.occupied .stat-value { color: #ff4444; }
        .stat-card.occupied .stat-icon { background: rgba(255, 68, 68, 0.2); color: #ff4444; }

        .stat-card.entries .stat-value { color: #ffaa00; }
        .stat-card.entries .stat-icon { background: rgba(255, 170, 0, 0.2); color: #ffaa00; }

        /* Occupancy pie card */
        .pie-card {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .pie-wrapper {
            position: relative;
            width: 140px;
            height: 140px;
            margin: 0 auto;
        }

        .pie-chart {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: conic-gradient(#ff4444 0%, rgba(0, 255, 136, 0.2) 0%);
            border: 8px solid #0f1629;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.3);
        }

        .pie-center {
            position: absolute;
            inset: 18px;
            border-radius: 50%;
            background: #0f1629;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            gap: 4px;
        }

        .pie-percent {
            font-size: 24px;
            font-weight: 700;
            color: #ff8888;
        }

        .pie-label {
            font-size: 12px;
            color: #8b8b8b;
        }

        .pie-legend {
            display: flex;
            justify-content: center;
            gap: 12px;
            font-size: 12px;
            color: #8b8b8b;
        }

        .pie-legend .dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 6px;
        }

        /* Toggle bar for feeds */
        .toggle-bar {
            display: flex;
            gap: 12px;
            margin: 16px 0 8px 0;
        }

        /* Dashboard modal */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.65);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 300;
        }

        .modal {
            background: #0f1629;
            border: 1px solid #1a2332;
            border-radius: 12px;
            padding: 20px;
            max-width: 1100px;
            width: 95%;
            max-height: 90vh;
            overflow: auto;
            box-shadow: 0 10px 40px rgba(0,0,0,0.4);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .modal-title {
            font-size: 18px;
            font-weight: 600;
            color: white;
        }

        .modal-close {
            background: #1a2332;
            border: none;
            color: #8b8b8b;
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
        }

        .modal-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 16px;
        }

        .modal-card {
            background: #131a2e;
            border: 1px solid #1a2332;
            border-radius: 12px;
            padding: 16px;
        }

        .modal-card h3 {
            margin-bottom: 10px;
            color: white;
            font-size: 16px;
        }

        .mini-pie {
            width: 160px;
            height: 160px;
            border-radius: 50%;
            border: 8px solid #0f1629;
            margin: 0 auto;
            box-shadow: inset 0 0 18px rgba(0,0,0,0.3);
        }

        .mini-pie-center {
            text-align: center;
            margin-top: -90px;
            color: #e0e0e0;
            font-weight: 700;
            font-size: 18px;
        }

        .log-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }

        .log-table th, .log-table td {
            padding: 6px 8px;
            border-bottom: 1px solid #1a2332;
            text-align: left;
        }

        .log-table th {
            color: #8b8b8b;
            font-weight: 600;
        }

        /* Video Feed Section */
        .video-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        .video-card {
            background: #131a2e;
            border: 1px solid #1a2332;
            border-radius: 12px;
            overflow: hidden;
        }

        .video-header {
            padding: 16px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #1a2332;
        }

        .video-title {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .video-title h3 {
            font-size: 16px;
            font-weight: 600;
            color: white;
        }

        .status-badge {
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .status-badge.active {
            background: rgba(0, 255, 136, 0.2);
            color: #00ff88;
        }

        .video-info {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .info-pill {
            padding: 4px 10px;
            background: #1a2332;
            border-radius: 6px;
            font-size: 11px;
            color: #8b8b8b;
        }

        .info-pill.live {
            background: rgba(255, 68, 68, 0.2);
            color: #ff4444;
        }

        .video-content {
            position: relative;
            background: #0a0e27;
            aspect-ratio: 16/9;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #parking-canvas.annotation-active {
            cursor: crosshair !important;
            border: 2px solid #00d4ff;
            box-shadow: 0 0 10px rgba(0, 212, 255, 0.5);
        }

        .video-feed {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .video-placeholder {
            width: 80px;
            height: 80px;
            background: #1a2332;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            color: #3a3a3a;
        }

        .video-footer {
            padding: 12px 20px;
            background: #0f1629;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
            color: #8b8b8b;
        }

        /* Main Content Grid */
        .main-grid {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 20px;
        }

        /* Parking Layout */
        .parking-layout-card {
            background: #131a2e;
            border: 1px solid #1a2332;
            border-radius: 12px;
            padding: 24px;
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .card-header h2 {
            font-size: 20px;
            font-weight: 600;
            color: white;
        }

        .legend {
            display: flex;
            gap: 16px;
            font-size: 12px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .legend-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .legend-dot.available { background: #00ff88; }
        .legend-dot.occupied { background: #ff4444; }

        .parking-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 8px;
            margin-bottom: 16px;
        }

        .parking-space {
            aspect-ratio: 1;
            border: 2px solid #1a2332;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .parking-space:hover {
            transform: scale(1.05);
            border-color: #00d4ff;
        }

        .parking-space.available {
            background: rgba(0, 255, 136, 0.1);
            border-color: rgba(0, 255, 136, 0.3);
            color: #00ff88;
        }

        .parking-space.occupied {
            background: rgba(255, 68, 68, 0.1);
            border-color: rgba(255, 68, 68, 0.3);
            color: #ff4444;
        }

        .parking-space.occupied::before {
            content: 'üöó';
            font-size: 20px;
        }

        .row-label {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .row-label span {
            width: 30px;
            font-weight: 600;
            color: #8b8b8b;
        }

        /* Detected Plates */
        .plates-card {
            background: #131a2e;
            border: 1px solid #1a2332;
            border-radius: 12px;
            padding: 24px;
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        .plates-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .plates-header h2 {
            font-size: 20px;
            font-weight: 600;
            color: white;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .plates-list {
            flex: 1;
            overflow-y: auto;
            max-height: 600px;
        }

        .plate-entry {
            background: #0f1629;
            border: 1px solid #1a2332;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .plate-info {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .plate-number {
            font-size: 18px;
            font-weight: 700;
            color: white;
            font-family: 'Courier New', monospace;
        }

        .plate-time {
            font-size: 12px;
            color: #8b8b8b;
        }

        .plate-confidence {
            padding: 4px 10px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 600;
        }

        .confidence-high {
            background: rgba(0, 255, 136, 0.2);
            color: #00ff88;
        }

        .confidence-medium {
            background: rgba(255, 170, 0, 0.2);
            color: #ffaa00;
        }

        .confidence-low {
            background: rgba(139, 139, 139, 0.2);
            color: #8b8b8b;
        }

        .direction-arrow {
            font-size: 20px;
        }

        .direction-in { color: #00ff88; }
        .direction-out { color: #ffaa00; }

        .plates-footer {
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid #1a2332;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
            color: #8b8b8b;
        }

        /* Annotation Mode */
        .annotation-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            z-index: 1000;
            overflow: auto;
            pointer-events: auto;
        }

        .annotation-overlay.active {
            display: flex;
        }

        .annotation-panel {
            background: #131a2e;
            border: 1px solid #1a2332;
            border-radius: 12px;
            padding: 20px;
            margin: 20px;
            max-width: 400px;
            width: auto;
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1002;
            pointer-events: auto;
        }
        
        .annotation-canvas-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            margin-top: 80px;
            overflow: auto;
            pointer-events: none; /* Allow clicks to pass through to canvas */
        }
        
        .annotation-canvas-container #parking-canvas {
            max-width: 95vw;
            max-height: 85vh;
            width: auto;
            height: auto;
            object-fit: contain;
            border: 3px solid #00d4ff;
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.6);
            background: #000;
            pointer-events: auto; /* Canvas itself should receive clicks */
            cursor: crosshair;
        }

        .annotation-panel h3 {
            margin-bottom: 16px;
            color: white;
        }

        .annotation-controls {
            display: flex;
            gap: 12px;
            margin-top: 20px;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: #00d4ff;
            color: white;
        }

        .btn-primary:hover {
            background: #00a8cc;
        }

        .btn-secondary {
            background: #1a2332;
            color: #8b8b8b;
        }

        .btn-secondary:hover {
            background: #252d3f;
            color: white;
        }

        /* Controls */
        .controls {
            display: flex;
            gap: 12px;
            margin-top: 16px;
        }

        .btn-small {
            padding: 8px 16px;
            font-size: 12px;
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #0f1629;
        }

        ::-webkit-scrollbar-thumb {
            background: #1a2332;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #252d3f;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <div class="header">
        <div class="logo-section">
            <div class="logo">P</div>
            <div class="logo-text">
                <h1>ParkVision</h1>
                <p>Smart Parking Management</p>
            </div>
        </div>
        <div class="header-right">
            <button class="icon-btn">
                üîî
                <span class="notification-badge"></span>
            </button>
            <button class="icon-btn" id="settings-btn" onclick="openDashboard()">‚öôÔ∏è</button>
            <div class="status-indicator">
                <div class="status-dot"></div>
                <span>System Online</span>
            </div>
        </div>
    </div>

    <!-- Main Container -->
    <div class="container">
        <!-- Statistics Cards -->
        <div class="stats-grid">
            <div class="stat-card total">
                <div class="stat-header">
                    <div>
                        <div class="stat-title">Total Spaces</div>
                        <div class="stat-value" id="total-spaces">0</div>
                        <div class="stat-subtitle">From annotations</div>
                    </div>
                    <div class="stat-icon">P</div>
                </div>
            </div>
            <div class="stat-card available">
                <div class="stat-header">
                    <div>
                        <div class="stat-title">Available</div>
                        <div class="stat-value" id="available-spaces">0</div>
                        <div class="stat-subtitle" id="available-percent">0% capacity</div>
                    </div>
                    <div class="stat-icon">üöó</div>
                </div>
            </div>
            <div class="stat-card occupied">
                <div class="stat-header">
                    <div>
                        <div class="stat-title">Occupied</div>
                        <div class="stat-value" id="occupied-spaces">0</div>
                        <div class="stat-subtitle" id="occupied-percent">0% utilized</div>
                    </div>
                    <div class="stat-icon">üöó</div>
                </div>
            </div>
            <div class="stat-card pie-card">
                <div class="stat-header">
                    <div>
                        <div class="stat-title">Occupancy Ratio</div>
                        <div class="stat-subtitle">Share of total spaces</div>
                    </div>
                </div>
                <div class="pie-wrapper">
                    <div class="pie-chart" id="occupancy-pie"></div>
                    <div class="pie-center">
                        <div class="pie-percent" id="occupancy-percent-text">0%</div>
                        <div class="pie-label">Occupied</div>
                    </div>
                </div>
                <div class="pie-legend">
                    <span><span class="dot" style="background:#ff4444;"></span>Occupied</span>
                    <span><span class="dot" style="background:#00ff88;"></span>Available</span>
                </div>
            </div>
            <div class="stat-card entries">
                <div class="stat-header">
                    <div>
                        <div class="stat-title">Today's Entries</div>
                        <div class="stat-value" id="today-entries">0</div>
                        <div class="stat-subtitle">+12% from yesterday</div>
                    </div>
                    <div class="stat-icon">üìà</div>
                </div>
            </div>
        </div>

        <!-- Feed toggles -->
        <div class="toggle-bar">
            <button class="btn btn-secondary" id="toggle-gate-btn" onclick="toggleGateFeed()">Show Plate Feed</button>
            <button class="btn btn-secondary" id="toggle-parking-btn" onclick="toggleParkingFeed()">Show Parking Feed</button>
        </div>

        <!-- Video Feeds -->
        <div class="video-section">
            <!-- Gate Camera (NPR) -->
            <div class="video-card" id="gate-card" style="display: none;">
                <div class="video-header">
                    <div class="video-title">
                        <h3>Plate Detection</h3>
                        <span class="status-badge active">Active</span>
                    </div>
                    <div class="video-info">
                        <span class="info-pill live">LIVE</span>
                        <span class="info-pill">CAM-01</span>
                        <span class="info-pill">üì∂ 30 FPS</span>
                    </div>
                </div>
                <div class="video-content" id="gate-video-container">
                    <div class="video-placeholder">üìπ</div>
                    <canvas id="gate-canvas" class="video-feed" style="display: none;"></canvas>
                </div>
                <div class="video-footer">
                    <span>Entrance Gate Camera</span>
                    <button class="btn btn-secondary btn-small" onclick="startGateCamera()">Start Camera</button>
                </div>
            </div>

            <!-- Parking Lot Camera (PSD1) -->
            <div class="video-card" id="parking-card" style="display: none;">
                <div class="video-header">
                    <div class="video-title">
                        <h3>Space Detection</h3>
                        <span class="status-badge active">Active</span>
                    </div>
                    <div class="video-info">
                        <span class="info-pill live">LIVE</span>
                        <span class="info-pill">CAM-02</span>
                        <span class="info-pill">üì∂ 30 FPS</span>
                    </div>
                </div>
                <div class="video-content" id="parking-video-container">
                    <div class="video-placeholder">üìπ</div>
                    <canvas id="parking-canvas" class="video-feed" style="display: none;"></canvas>
                </div>
                <div class="video-footer">
                    <span>Parking Area Overview</span>
                    <div class="controls">
                        <button class="btn btn-secondary btn-small" onclick="startParkingCamera()">Start Camera</button>
                        <button class="btn btn-primary btn-small" onclick="captureFrameForAnnotation()">Capture Frame</button>
                        <button class="btn btn-primary btn-small" id="annotate-btn" onclick="startAnnotationMode()" style="display: none;">Annotate Spaces</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Main Content Grid -->
        <div class="main-grid">
            <!-- Parking Layout -->
            <div class="parking-layout-card">
                <div class="card-header">
                    <h2>Parking Layout</h2>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-dot available"></div>
                            <span>Available (<span id="legend-available">20</span>)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-dot occupied"></div>
                            <span>Occupied (<span id="legend-occupied">12</span>)</span>
                        </div>
                    </div>
                </div>
                <div id="parking-grid-container">
                    <!-- Parking grid will be generated here -->
                </div>
            </div>

            <!-- Detected Plates -->
            <div class="plates-card">
                <div class="plates-header">
                    <h2>üöó Detected Plates</h2>
                    <div class="status-dot"></div>
                </div>
                <div class="plates-list" id="plates-list">
                    <!-- Plate entries will be added here -->
                </div>
                <div class="plates-footer">
                    <span id="last-update">Last updated: Just now</span>
                    <span>v1.0.0</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Dashboard Modal -->
    <div class="modal-overlay" id="dashboard-modal">
        <div class="modal">
            <div class="modal-header">
                <div class="modal-title">Analytics Dashboard</div>
                <button class="modal-close" onclick="closeDashboard()">Close</button>
            </div>
            <div class="modal-grid">
                <div class="modal-card">
                    <h3>Parking Occupancy (all-time)</h3>
                    <div class="mini-pie" id="history-occupancy-pie"></div>
                    <div class="mini-pie-center" id="history-occupancy-text">0%</div>
                    <div class="pie-legend" style="margin-top:12px;">
                        <span><span class="dot" style="background:#ff4444;"></span>Occupied events</span>
                        <span><span class="dot" style="background:#00ff88;"></span>Empty events</span>
                    </div>
                </div>
                <div class="modal-card">
                    <h3>Unique Plates (all-time)</h3>
                    <p style="color:#8b8b8b;margin-bottom:8px;">Total unique: <span id="unique-plates-count">0</span></p>
                    <p style="color:#8b8b8b;margin-bottom:12px;">Total detections: <span id="total-plate-detections">0</span></p>
                    <div id="top-plates-list" style="max-height:200px;overflow:auto;"></div>
                </div>
                <div class="modal-card" style="grid-column: 1 / -1;">
                    <h3>Per-Space Occupancy Changes</h3>
                    <div style="overflow:auto; max-height:240px;">
                        <table class="log-table" id="space-log-table">
                            <thead>
                                <tr>
                                    <th>Space</th>
                                    <th>Occupied events</th>
                                    <th>Empty events</th>
                                    <th>Last state</th>
                                </tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Annotation Overlay -->
    <div class="annotation-overlay" id="annotation-overlay">
        <div class="annotation-panel">
            <h3>Annotate Parking Spaces</h3>
            <p style="color: #8b8b8b; margin-bottom: 16px; font-size: 13px;">
                <strong>Instructions:</strong><br>
                1. Click on the image to add points<br>
                2. Press <strong>ENTER</strong> or <strong>'S'</strong> to save current polygon<br>
                3. Press <strong>'D'</strong> to delete last polygon<br>
                4. Press <strong>'A'</strong> or click "Save All" when done
            </p>
            <div class="annotation-controls">
                <button class="btn btn-primary" onclick="saveCurrentPolygon()" style="width: 100%; margin-bottom: 8px; background: #00d4ff; color: #000;">Save Current (S)</button>
                <button class="btn btn-primary" onclick="saveAllAnnotations()" style="width: 100%; margin-bottom: 8px;">Save All & Finish (A)</button>
                <button class="btn btn-secondary" onclick="cancelAnnotation()" style="width: 100%;">Cancel</button>
            </div>
        </div>
        <div class="annotation-canvas-container" id="annotation-canvas-container">
            <!-- Canvas will be moved here during annotation -->
        </div>
    </div>

    <script>
        // Global state
        let gateCameraActive = false;
        let parkingCameraActive = false;
        let annotationMode = false;
        let parkingSpaces = [];
        let detectedPlates = [];
        let parkingLayout = [];
        let gateStream = null;
        let parkingStream = null;

        // Parking spaces configuration
        let parkingSpacesConfig = null;
        let parkingSpacesMap = new Map(); // space_id -> DOM element

        // Initialize parking grid - empty initially
        function initParkingGrid() {
            const container = document.getElementById('parking-grid-container');
            container.innerHTML = '';
            
            // Show empty state message
            const emptyMsg = document.createElement('div');
            emptyMsg.id = 'parking-empty-state';
            emptyMsg.style.padding = '40px';
            emptyMsg.style.textAlign = 'center';
            emptyMsg.style.color = '#8b8b8b';
            emptyMsg.innerHTML = `
                <div style="font-size: 48px; margin-bottom: 16px;">üöó</div>
                <div style="font-size: 16px; margin-bottom: 8px;">No parking spaces configured</div>
                <div style="font-size: 14px; color: #666;">Go to "Space Detection" tab and click "Annotate Spaces" to define parking spaces</div>
            `;
            container.appendChild(emptyMsg);
        }

        // Load parking spaces from configuration
        function loadParkingSpacesFromConfig(config) {
            parkingSpacesConfig = config;
            const container = document.getElementById('parking-grid-container');
            container.innerHTML = '';
            
            // Remove empty state
            const emptyMsg = document.getElementById('parking-empty-state');
            if (emptyMsg) emptyMsg.remove();
            
            if (!config || !config.spaces || config.spaces.length === 0) {
                initParkingGrid();
                // Update total spaces to 0
                const totalEl = document.getElementById('total-spaces');
                if (totalEl) totalEl.textContent = '0';
                return;
            }
            
            // Create a flexible grid layout
            const grid = document.createElement('div');
            grid.className = 'parking-grid';
            grid.style.gridTemplateColumns = 'repeat(auto-fill, minmax(80px, 1fr))';
            grid.style.gap = '8px';
            
            // Create parking space elements
            config.spaces.forEach((space, index) => {
                const spaceEl = document.createElement('div');
                const spaceId = space.space_id || space.id || `space-${index + 1}`;
                spaceEl.className = 'parking-space available';
                spaceEl.id = `space-${spaceId}`;
                spaceEl.dataset.spaceId = spaceId;
                spaceEl.textContent = space.name || spaceId;
                spaceEl.title = `Space ${spaceId}`;
                spaceEl.onclick = () => selectSpace(spaceId);
                
                grid.appendChild(spaceEl);
                parkingSpacesMap.set(spaceId, spaceEl);
            });
            
            container.appendChild(grid);
            
            // Update total spaces from config (initially all available)
            const totalSpaces = config.spaces.length;
            updateParkingLayout(totalSpaces, 0, {}, totalSpaces); // Will be updated by real-time data
        }

        // Load parking config from API
        async function loadParkingConfig() {
            try {
                // Try to get the latest config from the server
                // First, check if there's a saved config
                const response = await fetch('/api/realtime/parking-status');
                if (response.ok) {
                    const status = await response.json();
                    // If we have space data, try to reconstruct config
                    if (status.spaces && Object.keys(status.spaces).length > 0) {
                        // We have spaces, but need the full config
                        // For now, create spaces from the status
                        const spaces = Object.keys(status.spaces).map(spaceId => ({
                            space_id: spaceId,
                            name: spaceId
                        }));
                        loadParkingSpacesFromConfig({ spaces });
                    }
                }
            } catch (error) {
                console.error('Error loading parking config:', error);
            }
        }

        function selectSpace(spaceId) {
            console.log('Selected space:', spaceId);
        }

        // Start gate camera (NPR)
        async function startGateCamera() {
            if (gateCameraActive) return;
            
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                gateStream = stream;
                const video = document.createElement('video');
                video.srcObject = stream;
                video.autoplay = true;
                video.playsInline = true;
                
                const canvas = document.getElementById('gate-canvas');
                const ctx = canvas.getContext('2d');
                
                video.onloadedmetadata = () => {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    canvas.style.display = 'block';
                    document.querySelector('#gate-video-container .video-placeholder').style.display = 'none';
                    gateCameraActive = true;
                    processGateFrame(video, canvas, ctx);
                };
            } catch (error) {
                console.error('Error accessing camera:', error);
                alert('Could not access camera. Please check permissions.');
            }
        }

        let frameCount = 0;
        async function processGateFrame(video, canvas, ctx) {
            if (!gateCameraActive) return;
            
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            
            // Send frame to API every 30 frames (approximately 1 second at 30fps)
            frameCount++;
            if (frameCount % 30 === 0) {
                try {
                    canvas.toBlob(async (blob) => {
                        const formData = new FormData();
                        formData.append('file', blob, 'frame.jpg');
                        
                        const response = await fetch('/api/realtime/plate-detect', {
                            method: 'POST',
                            body: formData
                        });
                        
                        if (response.ok) {
                            const data = await response.json();
                            console.log('Plate detection response:', data); // Debug log
                            if (data.detections && data.detections.length > 0) {
                                console.log(`Found ${data.detections.length} plate(s)`);
                                data.detections.forEach(det => {
                                    const plateNum = det.plate_number || det.plate || '';
                                    const confidence = (det.confidence || 0) * 100;
                                    console.log('Adding plate:', plateNum, 'confidence:', confidence);
                                    if (plateNum) {  // Only add if plate number is not empty
                                        addPlateEntry(plateNum, confidence, 'in');
                                    }
                                });
                            } else {
                                console.log('No detections in this frame');
                            }
                        } else {
                            const errorText = await response.text();
                            console.error('Plate detection error:', response.status, errorText);
                            // Show error to user
                            const errorData = JSON.parse(errorText).catch(() => ({detail: errorText}));
                            if (errorData.detail && errorData.detail.includes('license_plate_best.pt')) {
                                console.error('Model file not found - check server logs');
                            }
                        }
                    }, 'image/jpeg', 0.8);
                } catch (error) {
                    console.error('Error detecting plates:', error);
                }
            }
            
            requestAnimationFrame(() => processGateFrame(video, canvas, ctx));
        }

        // Start parking camera (PSD1)
        async function startParkingCamera() {
            if (parkingCameraActive) return;
            
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                parkingStream = stream;
                
                // Reuse existing video element or create new one
                if (!annotationVideo) {
                    annotationVideo = document.createElement('video');
                }
                annotationVideo.srcObject = stream;
                annotationVideo.autoplay = true;
                annotationVideo.playsInline = true;
                
                const canvas = document.getElementById('parking-canvas');
                const ctx = canvas.getContext('2d');
                
                annotationVideo.onloadedmetadata = () => {
                    canvas.width = annotationVideo.videoWidth;
                    canvas.height = annotationVideo.videoHeight;
                    canvas.style.display = 'block';
                    document.querySelector('#parking-video-container .video-placeholder').style.display = 'none';
                    parkingCameraActive = true;
                    processParkingFrame(annotationVideo, canvas, ctx);
                };
            } catch (error) {
                console.error('Error accessing camera:', error);
                alert('Could not access camera. Please check permissions.');
            }
        }

        let parkingFrameCount = 0;
        function processParkingFrame(video, canvas, ctx) {
            if (!parkingCameraActive) return;
            
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            
            // Don't draw live video if in annotation mode (we're using captured frame)
            if (annotationMode) {
                return; // Skip live video drawing during annotation
            }
            
            // Send frame to API for processing every 30 frames (approximately 1 second at 30fps)
            // Only send if we have a config loaded (check if parkingSpacesMap has spaces or config exists)
            parkingFrameCount++;
            
            // Don't send frames if:
            // 1. In annotation mode
            // 2. Config missing flag is set (from previous 400 error)
            // 3. No parking spaces config loaded
            // 4. No parking spaces map populated
            const hasConfig = parkingSpacesConfig !== null && 
                             parkingSpacesConfig !== undefined &&
                             (parkingSpacesConfig.spaces && parkingSpacesConfig.spaces.length > 0);
            const hasSpacesMap = parkingSpacesMap.size > 0;
            const configMissing = window.parkingConfigMissing === true;
            const shouldSendFrame = !annotationMode && 
                                   !configMissing &&
                                   parkingFrameCount % 30 === 0 && 
                                   (hasConfig || hasSpacesMap);
            
            if (shouldSendFrame) {
                try {
                    canvas.toBlob(async (blob) => {
                        const formData = new FormData();
                        formData.append('file', blob, 'frame.jpg');
                        
                        try {
                            const response = await fetch('/api/realtime/parking-detect', {
                                method: 'POST',
                                body: formData
                            });
                            
                            if (response.ok) {
                                const data = await response.json();
                                console.log('Parking detection response:', data); // Debug log
                                
                                // Load parking spaces if we have space data but no config loaded yet
                                if (data.spaces && Object.keys(data.spaces).length > 0 && parkingSpacesMap.size === 0) {
                                    // Create spaces from detected space IDs
                                    const spaces = Object.keys(data.spaces).map(spaceId => ({
                                        space_id: spaceId,
                                        name: spaceId
                                    }));
                                    loadParkingSpacesFromConfig({ spaces });
                                }
                                
                                // Update parking layout with real-time data
                                if (data.available !== undefined && data.occupied !== undefined) {
                                    updateParkingLayout(
                                        data.available, 
                                        data.occupied, 
                                        data.spaces || {},
                                        data.total_spaces || null
                                    );
                                }
                                
                                // Display annotated frame if returned
                                if (data.annotated_frame) {
                                    const canvas = document.getElementById('parking-canvas');
                                    const ctx = canvas.getContext('2d');
                                    const img = new Image();
                                    img.onload = () => {
                                        // Set canvas size to match image
                                        canvas.width = img.width;
                                        canvas.height = img.height;
                                        ctx.drawImage(img, 0, 0);
                                    };
                                    img.src = data.annotated_frame;
                                }
                            } else if (response.status === 400) {
                                // Config not loaded - stop sending frames if config is not available
                                const errorData = await response.json().catch(() => ({detail: 'Unknown error'}));
                                const errorMsg = errorData.detail || 'Configuration not loaded';
                                
                                // Only log once per session to avoid spam
                                if (!window.parkingConfigErrorLogged) {
                                    console.log('Parking config not loaded:', errorMsg);
                                    console.log('Please annotate and save parking spaces first.');
                                    window.parkingConfigErrorLogged = true;
                                    
                                    // Show user-friendly message
                                    const container = document.getElementById('parking-video-container');
                                    if (container && !container.querySelector('.config-warning')) {
                                        const warning = document.createElement('div');
                                        warning.className = 'config-warning';
                                        warning.style.cssText = 'position: absolute; top: 10px; left: 10px; background: rgba(255, 68, 68, 0.9); color: white; padding: 10px; border-radius: 5px; z-index: 1000; font-size: 14px; max-width: 300px;';
                                        warning.innerHTML = '‚ö†Ô∏è <strong>No parking spaces configured</strong><br>Click "Annotate Spaces" to define parking areas';
                                        container.appendChild(warning);
                                    }
                                }
                                
                                // Stop sending frames - set a flag to prevent further attempts
                                window.parkingConfigMissing = true;
                                parkingFrameCount = 0; // Reset counter to prevent immediate retry
                            } else {
                                const errorText = await response.text();
                                console.error('Parking detection error:', response.status, errorText);
                            }
                        } catch (error) {
                            console.error('Error detecting parking spaces:', error);
                        }
                    }, 'image/jpeg', 0.8);
                } catch (error) {
                    console.error('Error processing parking frame:', error);
                }
            }
            
            requestAnimationFrame(() => processParkingFrame(video, canvas, ctx));
        }
        
        let currentPolygon = [];
        let annotationPolygons = [];
        let capturedFrame = null; // Store the captured first frame
        let annotationVideo = null; // Reference to video element for capturing frame
        
        function setupAnnotationCanvas() {
            const canvas = document.getElementById('parking-canvas');
            if (!canvas) return;
            
            // Remove existing click listeners by cloning
            const oldCanvas = canvas;
            const newCanvas = oldCanvas.cloneNode(true);
            
            // Copy all attributes
            Array.from(oldCanvas.attributes).forEach(attr => {
                newCanvas.setAttribute(attr.name, attr.value);
            });
            
            // Copy style
            newCanvas.style.cssText = oldCanvas.style.cssText;
            
            oldCanvas.parentNode.replaceChild(newCanvas, oldCanvas);
            
            // Set canvas ID back
            newCanvas.id = 'parking-canvas';
            
            // Add click listener for annotation - use capture phase to ensure it fires
            newCanvas.addEventListener('click', (e) => {
                if (!annotationMode) return;
                
                // Prevent event from bubbling to overlay
                e.stopPropagation();
                
                const rect = newCanvas.getBoundingClientRect();
                const scaleX = newCanvas.width / rect.width;
                const scaleY = newCanvas.height / rect.height;
                const x = (e.clientX - rect.left) * scaleX;
                const y = (e.clientY - rect.top) * scaleY;
                
                // Ensure coordinates are within canvas bounds
                const clampedX = Math.max(0, Math.min(newCanvas.width, x));
                const clampedY = Math.max(0, Math.min(newCanvas.height, y));
                
                console.log('Click at:', clampedX, clampedY, 'Mode:', annotationMode);
                currentPolygon.push({ x: clampedX, y: clampedY });
                redrawAnnotationCanvas();
            }, true); // Use capture phase
            
            // Prevent overlay from blocking clicks
            const overlay = document.getElementById('annotation-overlay');
            if (overlay) {
                overlay.addEventListener('click', (e) => {
                    // If clicking on the overlay (not the panel), allow it to pass through
                    if (e.target === overlay) {
                        e.stopPropagation();
                    }
                });
            }
        }
        
        // Capture current frame for annotation
        async function captureFrameForAnnotation() {
            const canvas = document.getElementById('parking-canvas');
            
            if (!parkingCameraActive && !parkingStream) {
                alert('Please start the camera first.');
                return;
            }
            
            // Ensure we have a video element
            if (!annotationVideo && parkingStream) {
                annotationVideo = document.createElement('video');
                annotationVideo.srcObject = parkingStream;
                annotationVideo.autoplay = true;
                annotationVideo.playsInline = true;
                
                await new Promise((resolve) => {
                    annotationVideo.onloadedmetadata = () => {
                        annotationVideo.play();
                        resolve();
                    };
                });
                
                // Wait for frame to be ready
                await new Promise((resolve) => {
                    const checkFrame = () => {
                        if (annotationVideo.readyState >= 2) {
                            resolve();
                        } else {
                            setTimeout(checkFrame, 100);
                        }
                    };
                    checkFrame();
                });
            }
            
            if (annotationVideo && annotationVideo.readyState >= 2) {
                // Create a temporary canvas to capture the frame
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = annotationVideo.videoWidth || 640;
                tempCanvas.height = annotationVideo.videoHeight || 480;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(annotationVideo, 0, 0, tempCanvas.width, tempCanvas.height);
                
                // Create an image from the canvas
                capturedFrame = new Image();
                capturedFrame.src = tempCanvas.toDataURL();
                
                await new Promise((resolve) => {
                    capturedFrame.onload = () => {
                        // Set canvas size to match frame
                        canvas.width = capturedFrame.width;
                        canvas.height = capturedFrame.height;
                        canvas.style.display = 'block';
                        document.querySelector('#parking-video-container .video-placeholder').style.display = 'none';
                        resolve();
                    };
                });
                
                // Stop the live video processing temporarily
                parkingCameraActive = false;
                
                // Draw the captured frame
                redrawAnnotationCanvas();
                
                // Show annotation button
                document.getElementById('annotate-btn').style.display = 'inline-block';
                
                alert('Frame captured! Click "Annotate Spaces" to start drawing parking spaces.');
            } else {
                alert('Could not capture frame. Please ensure the camera is working.');
            }
        }
        
        function redrawAnnotationCanvas() {
            const canvas = document.getElementById('parking-canvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            if (!ctx) return;
            
            // Clear canvas first
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw the captured frame
            if (capturedFrame && capturedFrame.complete) {
                ctx.drawImage(capturedFrame, 0, 0, canvas.width, canvas.height);
            } else if (capturedFrame) {
                // Wait for image to load
                capturedFrame.onload = () => {
                    redrawAnnotationCanvas();
                };
                return;
            } else {
                // No frame captured yet
                ctx.fillStyle = '#1a2332';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#8b8b8b';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('No frame captured. Click "Capture Frame" first.', canvas.width / 2, canvas.height / 2);
                return;
            }
            
            // Draw all completed polygons
            ctx.strokeStyle = '#00ff88';
            ctx.lineWidth = 3;
            ctx.fillStyle = 'rgba(0, 255, 136, 0.2)';
            
            annotationPolygons.forEach((poly, idx) => {
                if (poly.length >= 3) {
                    ctx.beginPath();
                    ctx.moveTo(poly[0].x, poly[0].y);
                    for (let i = 1; i < poly.length; i++) {
                        ctx.lineTo(poly[i].x, poly[i].y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    
                    // Draw space number
                    const centerX = poly.reduce((sum, p) => sum + p.x, 0) / poly.length;
                    const centerY = poly.reduce((sum, p) => sum + p.y, 0) / poly.length;
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 18px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 3;
                    ctx.strokeText(`Space ${idx + 1}`, centerX, centerY);
                    ctx.fillText(`Space ${idx + 1}`, centerX, centerY);
                    ctx.fillStyle = 'rgba(0, 255, 136, 0.2)';
                    ctx.strokeStyle = '#00ff88';
                    ctx.lineWidth = 3;
                }
            });
            
            // Draw current polygon being drawn
            if (currentPolygon.length > 0) {
                ctx.strokeStyle = '#00d4ff';
                ctx.lineWidth = 3;
                ctx.beginPath();
                if (currentPolygon.length === 1) {
                    // Just a point
                    ctx.arc(currentPolygon[0].x, currentPolygon[0].y, 5, 0, 2 * Math.PI);
                    ctx.fillStyle = '#00d4ff';
                    ctx.fill();
                } else {
                    ctx.moveTo(currentPolygon[0].x, currentPolygon[0].y);
                    for (let i = 1; i < currentPolygon.length; i++) {
                        ctx.lineTo(currentPolygon[i].x, currentPolygon[i].y);
                    }
                    ctx.stroke();
                }
                
                // Draw points
                ctx.fillStyle = '#00d4ff';
                currentPolygon.forEach(p => {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 5, 0, 2 * Math.PI);
                    ctx.fill();
                    // Draw outer ring
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    ctx.strokeStyle = '#00d4ff';
                    ctx.lineWidth = 3;
                });
            }
        }

        // Annotation mode - start drawing on captured frame
        function startAnnotationMode() {
            // Check if we have a captured frame
            if (!capturedFrame) {
                alert('Please capture a frame first by clicking "Capture Frame".');
                return;
            }
            
            const canvas = document.getElementById('parking-canvas');
            const overlay = document.getElementById('annotation-overlay');
            const canvasContainer = document.getElementById('annotation-canvas-container');
            const originalContainer = document.getElementById('parking-video-container');
            
            // Ensure canvas is visible and has the right size
            if (capturedFrame) {
                // Calculate optimal size - maintain aspect ratio but make it large
                const maxWidth = window.innerWidth * 0.95;
                const maxHeight = window.innerHeight * 0.85;
                const aspectRatio = capturedFrame.width / capturedFrame.height;
                
                let displayWidth = capturedFrame.width;
                let displayHeight = capturedFrame.height;
                
                // Scale to fit screen while maintaining aspect ratio
                if (displayWidth > maxWidth) {
                    displayWidth = maxWidth;
                    displayHeight = displayWidth / aspectRatio;
                }
                if (displayHeight > maxHeight) {
                    displayHeight = maxHeight;
                    displayWidth = displayHeight * aspectRatio;
                }
                
                // Set canvas size to actual image size for drawing
                canvas.width = capturedFrame.width;
                canvas.height = capturedFrame.height;
                
                // Set display size for viewing
                canvas.style.width = displayWidth + 'px';
                canvas.style.height = displayHeight + 'px';
                canvas.style.display = 'block';
                canvas.style.maxWidth = '95vw';
                canvas.style.maxHeight = '85vh';
                canvas.style.objectFit = 'contain';
                
                // Move canvas to annotation container
                if (canvas.parentNode !== canvasContainer) {
                    canvasContainer.appendChild(canvas);
                }
            }
            
            // Enable annotation mode
            annotationMode = true;
            currentPolygon = [];
            annotationPolygons = [];
            overlay.classList.add('active');
            
            // Add visual indicator that canvas is active for annotation
            canvas.classList.add('annotation-active');
            
            setupAnnotationCanvas();
            redrawAnnotationCanvas();
            
            console.log('Annotation mode started. Click on the canvas to draw polygons.');
        }

        // Save current polygon being drawn (S key) - continues annotation mode
        function saveCurrentPolygon() {
            if (currentPolygon.length < 3) {
                alert('Please draw at least 3 points to create a polygon.');
                return;
            }
            
            // Add current polygon to completed polygons
            annotationPolygons.push([...currentPolygon]);
            currentPolygon = []; // Clear current polygon after adding
            redrawAnnotationCanvas(); // Redraw to show the new polygon
            
            // Show feedback
            const count = annotationPolygons.length;
            console.log(`Saved polygon ${count}. Continue drawing or press 'A' to save all and finish.`);
            
            // Optional: Show a brief message (non-blocking)
            const panel = document.querySelector('.annotation-panel p');
            if (panel) {
                const originalText = panel.innerHTML;
                panel.innerHTML = `<strong style="color: #00ff88;">‚úì Saved polygon ${count}</strong><br>Continue drawing or press 'A' to finish`;
                setTimeout(() => {
                    panel.innerHTML = originalText;
                }, 2000);
            }
        }
        
        // Save all polygons and finish (A key or button) - closes annotation mode
        async function saveAllAnnotations() {
            if (annotationPolygons.length === 0 && currentPolygon.length < 3) {
                alert('Please draw at least one parking space polygon.');
                return;
            }
            
            // Finish current polygon if it has enough points
            if (currentPolygon.length >= 3) {
                annotationPolygons.push([...currentPolygon]);
                currentPolygon = []; // Clear current polygon after adding
            }
            
            // Get canvas dimensions for coordinate normalization
            const canvas = document.getElementById('parking-canvas');
            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;
            
            // Convert to API format - use absolute pixel coordinates
            const spaces = annotationPolygons.map((poly, idx) => ({
                space_id: `space_${idx + 1}`,
                name: `Space ${idx + 1}`,
                polygon: poly.map(p => ({ 
                    x: Math.round(p.x), 
                    y: Math.round(p.y) 
                })),
                min_occupancy_ratio: 0.2
            }));
            
            try {
                const configName = `parking_spaces_${Date.now()}`;
                const response = await fetch('/api/annotations/save', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        config_name: configName,
                        spaces: spaces
                    })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    alert(`Saved ${spaces.length} parking spaces!`);
                    
                    // Load the saved configuration into the parking layout
                    if (result.config) {
                        loadParkingSpacesFromConfig(result.config);
                    } else {
                        loadParkingSpacesFromConfig({
                            name: configName,
                            spaces: spaces
                        });
                    }
                    
                    // Clear the config missing flag so frames can be sent
                    window.parkingConfigMissing = false;
                    window.parkingConfigErrorLogged = false;
                    
                    // Remove any warning messages
                    const container = document.getElementById('parking-video-container');
                    if (container) {
                        const warning = container.querySelector('.config-warning');
                        if (warning) warning.remove();
                    }
                    
                    // Resume video processing
                    cancelAnnotation();
                    
                    // Restart parking camera processing
                    if (parkingStream) {
                        parkingCameraActive = true;
                        const canvas = document.getElementById('parking-canvas');
                        const ctx = canvas.getContext('2d');
                        if (annotationVideo) {
                            processParkingFrame(annotationVideo, canvas, ctx);
                        }
                    }
                } else {
                    let errorMessage = 'Unknown error occurred';
                    try {
                        const errorData = await response.json();
                        // Handle different error response formats
                        if (errorData.detail) {
                            errorMessage = typeof errorData.detail === 'string' 
                                ? errorData.detail 
                                : JSON.stringify(errorData.detail);
                        } else if (errorData.message) {
                            errorMessage = typeof errorData.message === 'string'
                                ? errorData.message
                                : JSON.stringify(errorData.message);
                        } else if (typeof errorData === 'string') {
                            errorMessage = errorData;
                        } else {
                            errorMessage = JSON.stringify(errorData);
                        }
                    } catch (parseError) {
                        // If JSON parsing fails, try to get text
                        try {
                            const errorText = await response.text();
                            errorMessage = errorText || `HTTP ${response.status}: ${response.statusText}`;
                        } catch (textError) {
                            errorMessage = `HTTP ${response.status}: ${response.statusText}`;
                        }
                    }
                    console.error('Error saving annotations:', errorMessage);
                    alert(`Error saving annotations: ${errorMessage}`);
                }
            } catch (error) {
                console.error('Error:', error);
                const errorMessage = error instanceof Error ? error.message : String(error);
                alert(`Error saving annotations: ${errorMessage}`);
            }
        }
        
        // Handle keyboard shortcuts for annotation
        document.addEventListener('keydown', (e) => {
            if (!annotationMode) return;
            
            // Prevent default behavior for our shortcut keys
            if (['Enter', 'Return', 'd', 'D', 's', 'S', 'a', 'A'].includes(e.key)) {
                e.preventDefault();
            }
            
            if (e.key === 'Enter' || e.key === 'Return') {
                // Finish current polygon (same as S) - saves and continues
                saveCurrentPolygon();
            } else if (e.key === 'd' || e.key === 'D') {
                // Delete last polygon
                if (annotationPolygons.length > 0) {
                    annotationPolygons.pop();
                    redrawAnnotationCanvas(); // Redraw after deletion
                } else if (currentPolygon.length > 0) {
                    currentPolygon = [];
                    redrawAnnotationCanvas(); // Redraw after clearing current polygon
                }
            } else if (e.key === 's' || e.key === 'S') {
                // Save current polygon and continue
                saveCurrentPolygon();
            } else if (e.key === 'a' || e.key === 'A') {
                // Save all and finish
                saveAllAnnotations();
            }
        });

        function cancelAnnotation() {
            annotationMode = false;
            currentPolygon = [];
            // Keep annotationPolygons in case user wants to resume
            const overlay = document.getElementById('annotation-overlay');
            overlay.classList.remove('active');
            document.getElementById('annotate-btn').style.display = 'none';
            
            // Remove annotation-active class
            const canvas = document.getElementById('parking-canvas');
            const originalContainer = document.getElementById('parking-video-container');
            const canvasContainer = document.getElementById('annotation-canvas-container');
            
            if (canvas) {
                canvas.classList.remove('annotation-active');
                // Reset canvas display size
                canvas.style.width = '';
                canvas.style.height = '';
                canvas.style.maxWidth = '';
                canvas.style.maxHeight = '';
                canvas.style.objectFit = '';
                
                // Move canvas back to original container if needed
                if (canvas.parentNode === canvasContainer && originalContainer) {
                    originalContainer.appendChild(canvas);
                }
            }
            
            // Optionally clear the captured frame and resume live video
            // Uncomment below if you want to resume live video after canceling
            /*
            if (parkingStream && annotationVideo) {
                parkingCameraActive = true;
                const canvas = document.getElementById('parking-canvas');
                const ctx = canvas.getContext('2d');
                processParkingFrame(annotationVideo, canvas, ctx);
            }
            */
        }

        // Simulate plate detection
        function simulatePlateDetection() {
            const plates = ['MH 12 AB 1234', 'KA 01 XY 9876', 'DL 05 CD 5678', 'TN 09 EF 4321', 'GJ 18 GH 8765'];
            const plate = plates[Math.floor(Math.random() * plates.length)];
            const confidence = 95 + Math.random() * 5;
            const direction = Math.random() > 0.5 ? 'in' : 'out';
            
            addPlateEntry(plate, confidence, direction);
            updateTodayEntries();
        }

        function addPlateEntry(plate, confidence, direction) {
            if (!plate || plate.trim() === '') {
                console.warn('Attempted to add empty plate number');
                return;
            }
            
            const entry = {
                plate: plate.trim(),
                confidence: Math.max(0, Math.min(100, confidence)), // Clamp between 0-100
                direction: direction || 'in',
                time: new Date()
            };
            
            // Check for duplicates (same plate within last 5 seconds)
            const now = Date.now();
            const isDuplicate = detectedPlates.some(p => 
                (p.plate === entry.plate || p.plate_number === entry.plate) && 
                (now - new Date(p.time || p.timestamp).getTime()) < 5000
            );
            
            if (!isDuplicate) {
                detectedPlates.unshift(entry);
                if (detectedPlates.length > 50) detectedPlates.pop();
                
                console.log('Added plate entry:', entry);
                updatePlatesList();
                
                // Visual feedback - briefly highlight the plates list
                const listEl = document.getElementById('plates-list');
                if (listEl) {
                    listEl.style.transition = 'background-color 0.3s';
                    listEl.style.backgroundColor = 'rgba(0, 212, 255, 0.1)';
                    setTimeout(() => {
                        listEl.style.backgroundColor = '';
                    }, 500);
                }
            } else {
                console.log('Skipping duplicate plate:', entry.plate);
            }
        }

        function updatePlatesList() {
            const list = document.getElementById('plates-list');
            if (!list) {
                console.error('plates-list element not found');
                return;
            }
            
            list.innerHTML = '';
            
            if (detectedPlates.length === 0) {
                const emptyMsg = document.createElement('div');
                emptyMsg.style.padding = '20px';
                emptyMsg.style.textAlign = 'center';
                emptyMsg.style.color = '#8b8b8b';
                emptyMsg.textContent = 'No plates detected yet. Start the camera to begin detection.';
                list.appendChild(emptyMsg);
                return;
            }
            
            detectedPlates.slice(0, 10).forEach(entry => {
                const item = document.createElement('div');
                item.className = 'plate-entry';
                
                // Handle both Date objects and ISO strings
                const entryTime = entry.time instanceof Date ? entry.time : new Date(entry.time);
                const timeAgo = getTimeAgo(entryTime);
                
                // Ensure confidence is a number
                const confidence = typeof entry.confidence === 'number' ? entry.confidence : parseFloat(entry.confidence) || 0;
                const confClass = confidence > 97 ? 'confidence-high' : 
                                 confidence > 95 ? 'confidence-medium' : 'confidence-low';
                const dirArrow = entry.direction === 'in' ? '‚Üí' : '‚Üê';
                const dirClass = entry.direction === 'in' ? 'direction-in' : 'direction-out';
                
                item.innerHTML = `
                    <div class="plate-info">
                        <span class="direction-arrow ${dirClass}">${dirArrow}</span>
                        <div>
                            <div class="plate-number">${entry.plate || entry.plate_number || 'N/A'}</div>
                            <div class="plate-time">${timeAgo}</div>
                        </div>
                    </div>
                    <div class="plate-confidence ${confClass}">${confidence.toFixed(1)}%</div>
                `;
                
                list.appendChild(item);
            });
            
            const lastUpdateEl = document.getElementById('last-update');
            if (lastUpdateEl) {
                lastUpdateEl.textContent = 'Last updated: Just now';
            }
        }

        function getTimeAgo(date) {
            const seconds = Math.floor((new Date() - date) / 1000);
            if (seconds < 60) return `${seconds} sec ago`;
            const minutes = Math.floor(seconds / 60);
            if (minutes < 60) return `${minutes} min ago`;
            const hours = Math.floor(minutes / 60);
            return `${hours} hour${hours > 1 ? 's' : ''} ago`;
        }

        function updateTodayEntries() {
            const current = parseInt(document.getElementById('today-entries').textContent);
            document.getElementById('today-entries').textContent = current + 1;
        }

        // Update parking layout
        function updateParkingLayout(available, occupied, spaceStatuses = {}, totalSpaces = null) {
            const availEl = document.getElementById('available-spaces');
            const occEl = document.getElementById('occupied-spaces');
            const totalEl = document.getElementById('total-spaces');
            
            // Use provided total_spaces, or calculate from available + occupied, or use config
            let total = totalSpaces;
            if (!total && parkingSpacesConfig && parkingSpacesConfig.spaces) {
                total = parkingSpacesConfig.spaces.length;
            }
            if (!total) {
                total = (available || 0) + (occupied || 0);
            }
            
            if (availEl) availEl.textContent = available || 0;
            if (occEl) occEl.textContent = occupied || 0;
            if (totalEl) totalEl.textContent = total || 0;
            
            if (total > 0) {
                const availPercent = (((available || 0) / total) * 100).toFixed(1);
                const occPercent = (((occupied || 0) / total) * 100).toFixed(1);
                
                const availPercentEl = document.getElementById('available-percent');
                const occPercentEl = document.getElementById('occupied-percent');
                if (availPercentEl) availPercentEl.textContent = `${availPercent}% capacity`;
                if (occPercentEl) occPercentEl.textContent = `${occPercent}% utilized`;
            }
            
            const legendAvailEl = document.getElementById('legend-available');
            const legendOccEl = document.getElementById('legend-occupied');
            if (legendAvailEl) legendAvailEl.textContent = available || 0;
            if (legendOccEl) legendOccEl.textContent = occupied || 0;
            
            updateOccupancyPie(available || 0, occupied || 0, total || 0);
            // Update grid colors with actual space data
            updateGridColors(available, occupied, spaceStatuses);
        }

        function updateOccupancyPie(available, occupied, total) {
            const pie = document.getElementById('occupancy-pie');
            const percentText = document.getElementById('occupancy-percent-text');
            if (!pie || !percentText) return;

            const denom = total > 0 ? total : (available + occupied);
            const occPercent = denom > 0 ? Math.min(100, Math.max(0, (occupied / denom) * 100)) : 0;
            const availPercent = 100 - occPercent;

            // Conic gradient: occupied first slice, then available
            pie.style.background = `conic-gradient(#ff4444 ${occPercent}%, rgba(0, 255, 136, 0.2) ${occPercent}% 100%)`;
            percentText.textContent = `${occPercent.toFixed(1)}%`;

            // Also update legend numbers if present
            const legendAvailEl = document.getElementById('legend-available');
            const legendOccEl = document.getElementById('legend-occupied');
            if (legendAvailEl) legendAvailEl.textContent = available;
            if (legendOccEl) legendOccEl.textContent = occupied;
        }

        // Toggle feed visibility
        function toggleGateFeed() {
            const card = document.getElementById('gate-card');
            const btn = document.getElementById('toggle-gate-btn');
            if (!card || !btn) return;
            const isHidden = card.style.display === 'none' || card.style.display === '';
            card.style.display = isHidden ? 'block' : 'none';
            btn.textContent = isHidden ? 'Hide Plate Feed' : 'Show Plate Feed';
        }

        function toggleParkingFeed() {
            const card = document.getElementById('parking-card');
            const btn = document.getElementById('toggle-parking-btn');
            if (!card || !btn) return;
            const isHidden = card.style.display === 'none' || card.style.display === '';
            card.style.display = isHidden ? 'block' : 'none';
            btn.textContent = isHidden ? 'Hide Parking Feed' : 'Show Parking Feed';
        }

        document.addEventListener('DOMContentLoaded', () => {
            // Ensure feeds start hidden
            const gateCard = document.getElementById('gate-card');
            const parkingCard = document.getElementById('parking-card');
            if (gateCard) gateCard.style.display = 'none';
            if (parkingCard) parkingCard.style.display = 'none';
            const gateBtn = document.getElementById('toggle-gate-btn');
            const parkingBtn = document.getElementById('toggle-parking-btn');
            if (gateBtn) gateBtn.textContent = 'Show Plate Feed';
            if (parkingBtn) parkingBtn.textContent = 'Show Parking Feed';
        });

        async function openDashboard() {
            const modal = document.getElementById('dashboard-modal');
            if (!modal) return;
            modal.style.display = 'flex';
            await refreshDashboard();
        }

        function closeDashboard() {
            const modal = document.getElementById('dashboard-modal');
            if (modal) modal.style.display = 'none';
        }

        async function refreshDashboard() {
            try {
                const [parkingRes, plateRes] = await Promise.all([
                    fetch('/api/logs/parking-changes'),
                    fetch('/api/logs/plate-detections')
                ]);

                const parkingData = parkingRes.ok ? await parkingRes.json() : { logs: [] };
                const plateData = plateRes.ok ? await plateRes.json() : { logs: [] };

                renderParkingHistory(parkingData.logs || []);
                renderPlateHistory(plateData.logs || []);
            } catch (err) {
                console.error('Error loading dashboard data', err);
            }
        }

        function renderParkingHistory(logs) {
            let occEvents = 0;
            let emptyEvents = 0;
            const perSpace = new Map();

            logs.forEach(row => {
                const space = row.space_id || row.space || 'unknown';
                const newState = (row.new_state || row.new_state_change || '').toLowerCase();
                if (newState.includes('occupied')) occEvents++;
                else if (newState.includes('empty') || newState.includes('available')) emptyEvents++;

                if (!perSpace.has(space)) perSpace.set(space, { occ: 0, empty: 0, last: newState || '-' });
                const entry = perSpace.get(space);
                if (newState.includes('occupied')) entry.occ += 1;
                if (newState.includes('empty') || newState.includes('available')) entry.empty += 1;
                entry.last = newState || entry.last;
            });

            const pie = document.getElementById('history-occupancy-pie');
            const text = document.getElementById('history-occupancy-text');
            const denom = Math.max(1, occEvents + emptyEvents);
            const occPct = Math.min(100, Math.max(0, (occEvents / denom) * 100));
            if (pie) pie.style.background = `conic-gradient(#ff4444 ${occPct}%, rgba(0, 255, 136, 0.2) ${occPct}% 100%)`;
            if (text) text.textContent = `${occPct.toFixed(1)}%`;

            const tbody = document.querySelector('#space-log-table tbody');
            if (tbody) {
                tbody.innerHTML = '';
                const entries = Array.from(perSpace.entries()).sort((a,b)=>a[0].localeCompare(b[0]));
                entries.forEach(([space, data]) => {
                    const tr = document.createElement('tr');
                    tr.innerHTML = `
                        <td>${space}</td>
                        <td>${data.occ}</td>
                        <td>${data.empty}</td>
                        <td>${data.last || '-'}</td>
                    `;
                    tbody.appendChild(tr);
                });
                if (entries.length === 0) {
                    const tr = document.createElement('tr');
                    tr.innerHTML = `<td colspan="4" style="color:#8b8b8b;">No parking logs yet</td>`;
                    tbody.appendChild(tr);
                }
            }
        }

        function renderPlateHistory(logs) {
            const counts = new Map();
            logs.forEach(row => {
                const plate = (row.plate_number || row.plate || '').trim();
                if (!plate) return;
                counts.set(plate, (counts.get(plate) || 0) + 1);
            });

            const totalDetections = Array.from(counts.values()).reduce((a,b)=>a+b,0);
            const uniquePlates = counts.size;

            const uniqueEl = document.getElementById('unique-plates-count');
            const totalEl = document.getElementById('total-plate-detections');
            if (uniqueEl) uniqueEl.textContent = uniquePlates;
            if (totalEl) totalEl.textContent = totalDetections;

            const list = document.getElementById('top-plates-list');
            if (list) {
                list.innerHTML = '';
                const sorted = Array.from(counts.entries()).sort((a,b)=>b[1]-a[1]).slice(0,20);
                if (sorted.length === 0) {
                    list.innerHTML = `<div style="color:#8b8b8b;">No plate logs yet</div>`;
                } else {
                    sorted.forEach(([plate, count]) => {
                        const row = document.createElement('div');
                        row.style.display = 'flex';
                        row.style.justifyContent = 'space-between';
                        row.style.padding = '4px 0';
                        row.innerHTML = `<span>${plate}</span><span style="color:#8b8b8b;">${count}√ó</span>`;
                        list.appendChild(row);
                    });
                }
            }
        }

        function updateGridColors(available, occupied, spaceStatuses = {}) {
            // If we have individual space statuses, use them
            if (spaceStatuses && Object.keys(spaceStatuses).length > 0) {
                let availCount = 0;
                let occCount = 0;
                
                Object.entries(spaceStatuses).forEach(([spaceId, status]) => {
                    const spaceEl = parkingSpacesMap.get(spaceId);
                    if (spaceEl) {
                        // Check state - 'occupied' means red, 'empty' means green
                        const isOccupied = status.state === 'occupied' || 
                                         status.state === 'SpaceState.OCCUPIED' ||
                                         (status.occupancy_ratio && status.occupancy_ratio > 0.2);
                        
                        if (isOccupied) {
                            // Red for occupied
                            spaceEl.className = 'parking-space occupied';
                            spaceEl.style.background = 'rgba(255, 68, 68, 0.2)';
                            spaceEl.style.borderColor = 'rgba(255, 68, 68, 0.5)';
                            spaceEl.style.color = '#ff4444';
                            occCount++;
                        } else {
                            // Green for available
                            spaceEl.className = 'parking-space available';
                            spaceEl.style.background = 'rgba(0, 255, 136, 0.2)';
                            spaceEl.style.borderColor = 'rgba(0, 255, 136, 0.5)';
                            spaceEl.style.color = '#00ff88';
                            availCount++;
                        }
                    }
                });
                
                // Update counts if they don't match
                if (availCount + occCount > 0) {
                    // Counts are already set from spaceStatuses
                }
            } else {
                // Fallback: randomly assign based on available/occupied counts
                const spaces = Array.from(parkingSpacesMap.values());
                const total = spaces.length;
                if (total === 0) return;
                
                let availCount = 0;
                let occCount = 0;
                
                spaces.forEach((space, idx) => {
                    // Distribute occupied spaces evenly
                    const shouldBeOccupied = idx < Math.min(occupied, total);
                    if (shouldBeOccupied) {
                        // Red for occupied
                        space.className = 'parking-space occupied';
                        space.style.background = 'rgba(255, 68, 68, 0.2)';
                        space.style.borderColor = 'rgba(255, 68, 68, 0.5)';
                        space.style.color = '#ff4444';
                        occCount++;
                    } else {
                        // Green for available
                        space.className = 'parking-space available';
                        space.style.background = 'rgba(0, 255, 136, 0.2)';
                        space.style.borderColor = 'rgba(0, 255, 136, 0.5)';
                        space.style.color = '#00ff88';
                        availCount++;
                    }
                });
            }
        }

        // Fetch real-time data
        async function fetchDashboardStats() {
            try {
                const response = await fetch('/api/realtime/dashboard');
                if (response.ok) {
                    const data = await response.json();
                    console.log('Dashboard stats:', data); // Debug log
                    
                    // Update parking stats
                    if (data.parking) {
                        // Load parking spaces if we have space data but no config loaded yet
                        if (data.parking.spaces && Object.keys(data.parking.spaces).length > 0 && parkingSpacesMap.size === 0) {
                            const spaces = Object.keys(data.parking.spaces).map(spaceId => ({
                                space_id: spaceId,
                                name: spaceId
                            }));
                            loadParkingSpacesFromConfig({ spaces });
                        }
                        
                        updateParkingLayout(
                            data.parking.available || 0, 
                            data.parking.occupied || 0,
                            data.parking.spaces || {},
                            data.parking.total_spaces || null
                        );
                    }
                    
                    // Update plates - merge with existing to avoid duplicates
                    if (data.plates && data.plates.recent) {
                        // Merge new plates with existing ones, avoiding duplicates
                        const newPlates = data.plates.recent || [];
                        const existingPlateNumbers = new Set(detectedPlates.map(p => p.plate || p.plate_number));
                        
                        newPlates.forEach(plate => {
                            const plateNum = plate.plate_number || plate.plate;
                            if (!existingPlateNumbers.has(plateNum)) {
                                detectedPlates.unshift({
                                    plate: plateNum,
                                    confidence: (plate.confidence || 0) * 100,
                                    direction: plate.direction || 'in',
                                    time: new Date(plate.timestamp || Date.now())
                                });
                                existingPlateNumbers.add(plateNum);
                            }
                        });
                        
                        // Keep only last 50
                        if (detectedPlates.length > 50) {
                            detectedPlates = detectedPlates.slice(0, 50);
                        }
                        
                        // Update today's entries from plate detections (real count)
                        today_entries_count = data.plates.today_entries || today_entries_count || 0;
                        const todayEntriesEl = document.getElementById('today-entries');
                        if (todayEntriesEl) {
                            todayEntriesEl.textContent = today_entries_count;
                        }
                        updatePlatesList();
                    }
                } else {
                    console.error('Dashboard stats error:', response.status);
                }
            } catch (error) {
                console.error('Error fetching stats:', error);
            }
        }
        
        async function fetchParkingStatus() {
            try {
                const response = await fetch('/api/realtime/parking-status');
                if (response.ok) {
                    const data = await response.json();
                    updateParkingLayout(
                        data.available || 0, 
                        data.occupied || 0, 
                        data.spaces || {},
                        data.total_spaces || null
                    );
                }
            } catch (error) {
                console.error('Error fetching parking status:', error);
            }
        }
        
        async function fetchPlates() {
            try {
                const response = await fetch('/api/realtime/plates?limit=10');
                if (response.ok) {
                    const data = await response.json();
                    detectedPlates = data.plates || [];
                    today_entries_count = data.today_entries || 0;
                    document.getElementById('today-entries').textContent = today_entries_count;
                    updatePlatesList();
                }
            } catch (error) {
                console.error('Error fetching plates:', error);
            }
        }
        
        // Initialize
        initParkingGrid();
        setupAnnotationCanvas();
        
        // Try to load existing config on page load
        async function loadExistingConfig() {
            try {
                const response = await fetch('/api/annotations/current');
                if (response.ok) {
                    const result = await response.json();
                    if (result.success && result.config) {
                        loadParkingSpacesFromConfig(result.config);
                    }
                }
            } catch (error) {
                console.log('No existing config found, starting with empty layout');
            }
        }
        
        loadExistingConfig();
        fetchDashboardStats();
        
        // Poll for updates every 2 seconds
        setInterval(() => {
            fetchDashboardStats();
        }, 2000);
        
        // Initial load
        setTimeout(() => {
            fetchPlates();
            fetchParkingStatus();
        }, 500);
    </script>
</body>
</html>
